<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft Bot POV</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #e0e0e0;
      overflow: hidden;
    }

    .container {
      display: grid;
      grid-template-columns: 2fr 1fr;
      height: 100vh;
      gap: 1rem;
      padding: 1rem;
    }

    .main-view {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .viewport {
      background: #0f3460;
      border-radius: 12px;
      padding: 1.5rem;
      flex: 1;
      position: relative;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }

    .crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      pointer-events: none;
      z-index: 10;
    }

    .crosshair::before,
    .crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
    }

    .crosshair::before {
      width: 2px;
      height: 100%;
      left: 50%;
      transform: translateX(-50%);
    }

    .crosshair::after {
      height: 2px;
      width: 100%;
      top: 50%;
      transform: translateY(-50%);
    }

    .vision-canvas {
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, #87CEEB 0%, #98D8E8 50%, #7BC87C 100%);
      border-radius: 8px;
    }

    .status-bar {
      background: rgba(15, 52, 96, 0.95);
      border-radius: 8px;
      padding: 1rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
    }

    .stat {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .stat-label {
      font-size: 0.75rem;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: #22d3ee;
    }

    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      overflow-y: auto;
    }

    .panel {
      background: rgba(15, 52, 96, 0.95);
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .panel-title {
      font-size: 1.1rem;
      font-weight: 700;
      color: #22d3ee;
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .entity-list, .block-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      max-height: 300px;
      overflow-y: auto;
    }

    .entity-item, .block-item {
      background: rgba(34, 211, 238, 0.1);
      padding: 0.75rem;
      border-radius: 6px;
      border-left: 3px solid #22d3ee;
      font-size: 0.9rem;
    }

    .entity-hostile {
      border-left-color: #ef4444;
      background: rgba(239, 68, 68, 0.1);
    }

    .entity-player {
      border-left-color: #10b981;
      background: rgba(16, 185, 129, 0.1);
    }

    .distance {
      color: #94a3b8;
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }

    .connection-status {
      position: fixed;
      top: 1rem;
      right: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      z-index: 100;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .connected {
      background: rgba(16, 185, 129, 0.2);
      border: 2px solid #10b981;
      color: #10b981;
    }

    .connected .status-dot {
      background: #10b981;
    }

    .disconnected {
      background: rgba(239, 68, 68, 0.2);
      border: 2px solid #ef4444;
      color: #ef4444;
    }

    .disconnected .status-dot {
      background: #ef4444;
    }

    .inventory-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .inventory-slot {
      background: rgba(34, 211, 238, 0.1);
      padding: 0.5rem;
      border-radius: 4px;
      text-align: center;
      font-size: 0.75rem;
    }

    .slot-count {
      color: #22d3ee;
      font-weight: 600;
    }

    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(34, 211, 238, 0.5);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(34, 211, 238, 0.7);
    }
  </style>
</head>
<body>
  <div class="connection-status disconnected" id="connectionStatus">
    <div class="status-dot"></div>
    <span>Connecting...</span>
  </div>

  <div class="container">
    <div class="main-view">
      <div class="viewport">
        <div class="crosshair"></div>
        <canvas class="vision-canvas" id="visionCanvas"></canvas>
      </div>
      
      <div class="status-bar">
        <div class="stat">
          <div class="stat-label">Position</div>
          <div class="stat-value" id="position">--, --, --</div>
        </div>
        <div class="stat">
          <div class="stat-label">Health</div>
          <div class="stat-value" id="health">--</div>
        </div>
        <div class="stat">
          <div class="stat-label">Food</div>
          <div class="stat-value" id="food">--</div>
        </div>
        <div class="stat">
          <div class="stat-label">Time</div>
          <div class="stat-value" id="time">--</div>
        </div>
        <div class="stat">
          <div class="stat-label">Biome</div>
          <div class="stat-value" id="biome">--</div>
        </div>
        <div class="stat">
          <div class="stat-label">Looking At</div>
          <div class="stat-value" id="target">--</div>
        </div>
      </div>
    </div>

    <div class="sidebar">
      <div class="panel">
        <div class="panel-title">üì¶ Inventory</div>
        <div id="inventory">No items</div>
      </div>

      <div class="panel">
        <div class="panel-title">üëÅÔ∏è Entities in View</div>
        <div class="entity-list" id="entities">
          <div style="color: #94a3b8; font-size: 0.9rem;">No entities detected</div>
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">üß± Blocks in Sight</div>
        <div class="block-list" id="blocks">
          <div style="color: #94a3b8; font-size: 0.9rem;">No blocks detected</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const API_URL = 'http://127.0.0.1:3001/api/vision';
    const canvas = document.getElementById('visionCanvas');
    const ctx = canvas.getContext('2d');
    
    let lastVisionData = null;

    // Set canvas size
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      if (lastVisionData) drawScene(lastVisionData);
    }
    
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Draw the scene based on vision data
    function drawScene(vision) {
      const w = canvas.width;
      const h = canvas.height;
      
      // Sky gradient based on time
      const time = vision.time?.phase || 'day';
      let skyTop, skyBottom;
      
      switch(time) {
        case 'night':
          skyTop = '#0a1929';
          skyBottom = '#1e3a5f';
          break;
        case 'evening':
          skyTop = '#ff6b35';
          skyBottom = '#f7931e';
          break;
        case 'morning':
          skyTop = '#ffd89b';
          skyBottom = '#19547b';
          break;
        default: // day
          skyTop = '#87CEEB';
          skyBottom = '#98D8E8';
      }
      
      const gradient = ctx.createLinearGradient(0, 0, 0, h);
      gradient.addColorStop(0, skyTop);
      gradient.addColorStop(0.5, skyBottom);
      gradient.addColorStop(1, '#7BC87C');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);
      
      // Draw ground
      ctx.fillStyle = '#5a4a3a';
      ctx.fillRect(0, h * 0.6, w, h * 0.4);
      
      // Draw blocks in sight
      if (vision.blocksInSight && vision.blocksInSight.length > 0) {
        vision.blocksInSight.forEach((block, idx) => {
          const scale = 1 - (block.distance / 25);
          const size = 40 * scale;
          const x = w * 0.5 + (idx - vision.blocksInSight.length / 2) * (size + 10);
          const y = h * 0.5 - size / 2;
          
          // Block color based on type
          let color = getBlockColor(block.name);
          
          ctx.fillStyle = color;
          ctx.fillRect(x, y, size, size);
          
          // Lighter top
          ctx.fillStyle = lightenColor(color, 20);
          ctx.fillRect(x, y, size, size * 0.3);
          
          // Block name
          ctx.fillStyle = 'white';
          ctx.font = `${10 * scale}px monospace`;
          ctx.textAlign = 'center';
          ctx.fillText(block.name, x + size/2, y - 5);
        });
      }
      
      // Draw entities
      if (vision.entitiesInSight && vision.entitiesInSight.length > 0) {
        vision.entitiesInSight.forEach(entity => {
          if (entity.inView && entity.distance < 15) {
            const scale = 1 - (entity.distance / 20);
            const size = 30 * scale;
            const angle = Math.random() * Math.PI * 2; // Simplified positioning
            const x = w * 0.5 + Math.cos(angle) * entity.distance * 10;
            const y = h * 0.5 - size;
            
            // Entity shape
            if (entity.isPlayer) {
              ctx.fillStyle = '#10b981';
            } else if (entity.isHostile) {
              ctx.fillStyle = '#ef4444';
            } else {
              ctx.fillStyle = '#fbbf24';
            }
            
            ctx.fillRect(x - size/2, y, size, size * 1.5);
            
            // Name
            ctx.fillStyle = 'white';
            ctx.font = `${8 * scale}px monospace`;
            ctx.textAlign = 'center';
            ctx.fillText(entity.type, x, y - 5);
          }
        });
      }
      
      // Weather effects
      if (vision.weather?.isRaining) {
        ctx.strokeStyle = 'rgba(173, 216, 230, 0.5)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 100; i++) {
          const x = Math.random() * w;
          const y = Math.random() * h;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x - 2, y + 10);
          ctx.stroke();
        }
      }
    }

    function getBlockColor(name) {
      const colors = {
        'stone': '#7f7f7f',
        'dirt': '#8b6c42',
        'grass_block': '#5a8c3c',
        'wood': '#6b4423',
        'oak_log': '#6b4423',
        'sand': '#e5d4a5',
        'water': '#3498db',
        'lava': '#ff6347',
        'cobblestone': '#7f7f7f',
        'coal_ore': '#1a1a1a',
        'iron_ore': '#d4a574',
        'gold_ore': '#ffd700',
        'diamond_ore': '#00bcd4',
        'leaves': '#228b22',
        'glass': '#87ceeb'
      };
      
      for (let key in colors) {
        if (name.includes(key)) return colors[key];
      }
      
      return '#8b8b8b';
    }

    function lightenColor(color, percent) {
      const num = parseInt(color.replace("#",""), 16);
      const amt = Math.round(2.55 * percent);
      const R = Math.min(255, (num >> 16) + amt);
      const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
      const B = Math.min(255, (num & 0x0000FF) + amt);
      return "#" + (0x1000000 + R*0x10000 + G*0x100 + B).toString(16).slice(1);
    }

    // Update UI with vision data
    function updateUI(data) {
      lastVisionData = data;
      
      const vision = data.vision;
      
      // Update status bar
      document.getElementById('position').textContent = 
        `${vision.position.x}, ${vision.position.y}, ${vision.position.z}`;
      document.getElementById('health').textContent = 
        `${vision.health} / 20`;
      document.getElementById('food').textContent = 
        `${vision.food} / 20`;
      document.getElementById('time').textContent = 
        vision.time.phase || 'unknown';
      document.getElementById('biome').textContent = 
        vision.biome || 'unknown';
      document.getElementById('target').textContent = 
        vision.targetBlock ? vision.targetBlock.name : 'air';
      
      // Update inventory
      const invEl = document.getElementById('inventory');
      if (vision.inventory.slots.length > 0) {
        invEl.innerHTML = '<div class="inventory-grid">' +
          vision.inventory.slots.map(item => 
            `<div class="inventory-slot">
              <div>${item.name.split('_').join(' ')}</div>
              <div class="slot-count">√ó${item.count}</div>
            </div>`
          ).join('') +
          '</div>';
      } else {
        invEl.innerHTML = '<div style="color: #94a3b8;">Empty</div>';
      }
      
      // Update entities
      const entitiesEl = document.getElementById('entities');
      if (vision.entitiesInSight.length > 0) {
        entitiesEl.innerHTML = vision.entitiesInSight.map(entity => {
          let className = 'entity-item';
          if (entity.isHostile) className += ' entity-hostile';
          if (entity.isPlayer) className += ' entity-player';
          
          return `<div class="${className}">
            ${entity.isPlayer ? 'üë§' : 'üéØ'} ${entity.type || entity.name}
            <span class="distance">${entity.distance}m</span>
          </div>`;
        }).join('');
      } else {
        entitiesEl.innerHTML = '<div style="color: #94a3b8; font-size: 0.9rem;">No entities detected</div>';
      }
      
      // Update blocks
      const blocksEl = document.getElementById('blocks');
      if (vision.blocksInSight.length > 0) {
        blocksEl.innerHTML = vision.blocksInSight.slice(0, 10).map(block => 
          `<div class="block-item">
            üß± ${block.name}
            <span class="distance">${block.distance}m</span>
          </div>`
        ).join('');
      } else {
        blocksEl.innerHTML = '<div style="color: #94a3b8; font-size: 0.9rem;">No blocks detected</div>';
      }
      
      // Draw scene
      drawScene(vision);
    }

    // Fetch vision data
    async function fetchVision() {
      try {
        const response = await fetch(API_URL);
        const data = await response.json();
        
        if (data.status === 'success') {
          updateUI(data);
          updateConnectionStatus(true);
        } else {
          updateConnectionStatus(false, data.error);
        }
      } catch (err) {
        console.error('Failed to fetch vision:', err);
        updateConnectionStatus(false, 'Connection failed');
      }
    }

    function updateConnectionStatus(connected, message = '') {
      const statusEl = document.getElementById('connectionStatus');
      if (connected) {
        statusEl.className = 'connection-status connected';
        statusEl.querySelector('span').textContent = 'Connected';
      } else {
        statusEl.className = 'connection-status disconnected';
        statusEl.querySelector('span').textContent = message || 'Disconnected';
      }
    }

    // Start polling
    fetchVision();
    setInterval(fetchVision, 500); // Update twice per second
  </script>
</body>
</html>